1) При прерывании работы сценария test-trap.sh i не доходит до 100, и цикл не завершается. Поэтому происходит выход exit 1, отвечающий за аварийное завершение программы.
 trap перехватывает команду exit 1, и выполняется echo "Аварийное завершение", то есть то, что указано выполнить trap пр перехватке указанного сигнала.
2) При выполнении команды cat /proc/self дрйвер динмаически сгенерирует содержимое, считав инфоомацию с самого процесса. Поэтому каждый раз, когда мы будем читать из этой "директории", которая, по сути, является драйвером, будет генерироваться разное содержимое, и у считывающих процессов будут разные PID, так как это разные процессы.
$$ - переменная, содержащая PID процесса текущей командной оболочки. Директрория /proc/$$ будет генерироваться как директория конкретно процесса командной оболочки, а не считываюего процесса.
3) 0 - stdin; 1 - stdout; 2 - stderr;
4) то, что идет в вывод (то есть stdout, то есть с дескриптором 1), будет перенаправляться в /tmp/ls.out. Туда будет записан весь вывод команды.
А все ошибки (то есть stderr, то есть поток ошибок с дескриптором 2) будет направлен в файл ls.err.
После такого перенаправления получится, дескриптор 1 связан с ls.out, а  дескриптор 2 связан с ls.err.
5) При перенаправлении stdin, поток ввода будет тоже перенаправляться, и дескриптор 0 будет связан с ls.in. При этом y 0 -> ls.in уже нет права доступа на чтение, поскольку теперь ввод принадлежит не пользователю, а файлу ls.in, и у пользователя нет возможности его читать.
6)exec выполняет команду ps -l, при этом он замещает коды порожденного процесса shell кодами ps. Можно увидеть, что теперь у процесса ps -l будет pid и ppid процесса shell, а самого процесса shell уже не будет в выведенном списке, хотя сам shell не исчезнет и не закроется. 
При следующем вызове ps -l без exec все останется также, процесса sh снова не будет выведено, так как exec заместил его коды.
7)pos - указатель позиции чтения/записи.
Он указывает, на какой позиции мы остановились в чтении/записи. Его значение 14, значит мы записали 13 символов + символ перехода на новую строку, который автоматически записывается функцией echo (Test3 - 5 символов, Test333 - 7 символов, переход на новую строку между ними - 13-ый символ, переход на новую строку после - 14).
8)После удаления наш файл исчез из дерева файлов, и мы не можем прочитать его командой cat. Однако из-за того, что с ним связаны дескрипторы, он еще существует, и мы можем продолжать писать в него и читать из него, то есть работать как со старым файлом. Он будет удален только после его полного закрытия всеми дескрипторами.
